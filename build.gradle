import com.google.gson.GsonBuilder
import com.google.gson.Gson
import org.gradle.wrapper.*



buildscript {
    dependencies {
        classpath files('gradle/wrapper/gradle-wrapper.jar')
        classpath 'com.google.code.gson:gson:2.2.4'
    }
}

plugins {
    id 'java'
    id "com.ullink.msbuild" version "2.21" apply false
    id "de.undercouch.download" version "3.4.3" apply false
}

wrapper {
    gradleVersion = '4.9'
}

apply from: 'scripts/gradlew.gradle'
apply from: 'scripts/installer.gradle'

apply from: 'scripts/toolchain.gradle'
apply from: 'scripts/jdk.gradle'
apply from: 'scripts/maven.gradle'
// Tools must happen after maven
apply from: 'scripts/tools.gradle'
apply from: 'scripts/vscode.gradle'

ext.getGsonBuilder = {
    return new GsonBuilder()
}

def upgradeConfigFile = file("$buildDir/upgradeConfig.json")

def frcYear = '2018'

def upgradeConfigFileTask = tasks.register('generateUpgradeConfigFile', Task) { Task task ->
    task.outputs.file upgradeConfigFile

    def configurations = []
    configurations << toolsConfig()
    configurations << mavenConfigSetup()

    configurations.each {
        it.first(task)
    }

    doLast {
        def config = [:]

        config['FrcYear'] = frcYear

        configurations.each {
            it.second(config)
        }

        def gbuilder = getGsonBuilder()
        gbuilder.setPrettyPrinting()
        def json = gbuilder.create().toJson(config)

        upgradeConfigFile.parentFile.mkdirs()

        upgradeConfigFile.text = json
    }
}

def commonResources = { Zip zip->
    zip.dependsOn upgradeConfigFileTask
    zip.inputs.file upgradeConfigFile

    zip.from (upgradeConfigFile) {
        into '/installUtils'
    }

    msBuildExtraSetup(zip)

    toolsSetup(zip)
    mavenZipSetup(zip)
    vscodeZipSetup(zip)
}

def generateUpgradeResourcesTask = tasks.register('generateUpgradeResources', Zip) {
    baseName 'WPILib_UpgradeFiles'
    destinationDir file("$buildDir/outputs")
    duplicatesStrategy 'exclude'

    commonResources(it)
}

def generateUpgradeZipBaseTask = tasks.register('generateUpgradeZipBase', Zip) {
    baseName 'WPILibInstaller_Upgrade'
    destinationDir buildDir
    duplicatesStrategy 'exclude'

    dependsOn generateUpgradeResourcesTask
    inputs.file generateUpgradeResourcesTask.get().archivePath

    entryCompression = ZipEntryCompression.STORED


    // This MUST be first
    msBuildSetupMain(it)

    from (generateUpgradeResourcesTask.get().archivePath)
}


def upgradeInstallerName = 'WPILibInstaller_Upgrade.exe'
def upgradeInstaller = file("$buildDir/outputs/$upgradeInstallerName")

def upgradeInstallerTask = tasks.register('generateUpgradeInstaller', Task) {
    def zipFile = generateUpgradeZipBaseTask.get().archivePath
    inputs.file zipFile
    outputs.file upgradeInstaller

    dependsOn generateUpgradeZipBaseTask

    doLast {
        copy {
            from zipFile
            into "$buildDir/outputs"
            rename { upgradeInstallerName }
        }

        installerFile.withInputStream { InputStream inputStream ->
            RandomAccessFile foStream;
            try {
                foStream = new RandomAccessFile(upgradeInstaller, "rw");
                foStream.write(inputStream.getBytes())
            } finally {
                if (foStream != null) {
                    foStream.close();
                }
            }
        }
    }
}

def fullConfigFile = file("$buildDir/fullConfig.json")

def fullConfigFileTask = tasks.register('generateFullConfigFile', Task) { Task task ->
    task.outputs.file fullConfigFile

    def configurations = []
    configurations << gradleConfigTaskSetup()
    configurations << toolchainConfigTaskSetup()

    configurations.each {
        it.first(task)
    }

    doLast {
        def config = [:]

        configurations.each {
            it.second(config)
        }

        def gbuilder = new GsonBuilder()
        gbuilder.setPrettyPrinting()
        def json = gbuilder.create().toJson(config)

        fullConfigFile.parentFile.mkdirs()

        fullConfigFile.text = json
    }
}


def generateFullResources32Task = tasks.register('generateFullResources32', Zip) {
    baseName 'WPILib_FullFiles32'
    destinationDir file("$buildDir/outputs")
    duplicatesStrategy 'exclude'

    dependsOn fullConfigFileTask
    inputs.file fullConfigFile

    it.from (fullConfigFile) {
        into '/installUtils'
    }

    commonResources(it)

    gradleZipTaskSetup(it)
    toolchainZipSetup(it)
    jdkZipSetup32(it)
}

def generateFullZip32BaseTask = tasks.register('generateFileZip32Base', Zip) {
    baseName 'WPILibInstaller_Full32'
    destinationDir buildDir
    duplicatesStrategy 'exclude'

    dependsOn generateFullResources32Task
    inputs.file generateFullResources32Task.get().archivePath

    entryCompression = ZipEntryCompression.STORED


    // This MUST be first
    msBuildSetupMain(it)

    from (generateFullResources32Task.get().archivePath) {
        rename { 'files.zip' }
    }
}


def fullInstaller32Name = 'WPILibInstaller_Full32.exe'
def fullInstaller32 = file("$buildDir/outputs/$fullInstaller32Name")

def fullInstallerTask32 = tasks.register('generateFullInstaller32', Task) {
    def zipFile = generateFullZip32BaseTask.get().archivePath
    inputs.file zipFile
    outputs.file fullInstaller32

    dependsOn generateFullZip32BaseTask

    doLast {
        copy {
            from zipFile
            into "$buildDir/outputs"
            rename { fullInstaller32Name }
        }

        installerFile.withInputStream { InputStream inputStream ->
            RandomAccessFile foStream;
            try {
                foStream = new RandomAccessFile(fullInstaller32, "rw");
                foStream.write(inputStream.getBytes())
            } finally {
                if (foStream != null) {
                    foStream.close();
                }
            }
        }
    }
}

def generateFullResources64Task = tasks.register('generateFullResources64', Zip) {
    baseName 'WPILib_FullFiles64'
    destinationDir file("$buildDir/outputs")
    duplicatesStrategy 'exclude'

    dependsOn fullConfigFileTask
    inputs.file fullConfigFile

    it.from (fullConfigFile) {
        into '/installUtils'
    }

    commonResources(it)

    gradleZipTaskSetup(it)
    toolchainZipSetup(it)
    jdkZipSetup64(it)
}

def generateFullZip64BaseTask = tasks.register('generateFileZip64Base', Zip) {
    baseName 'WPILibInstaller_Full64'
    destinationDir buildDir
    duplicatesStrategy 'exclude'

    dependsOn generateFullResources64Task
    inputs.file generateFullResources64Task.get().archivePath

    entryCompression = ZipEntryCompression.STORED


    // This MUST be first
    msBuildSetupMain(it)

    from (generateFullResources64Task.get().archivePath) {
        rename { 'files.zip' }
    }
}


def fullInstaller64Name = 'WPILibInstaller_Full64.exe'
def fullInstaller64 = file("$buildDir/outputs/$fullInstaller64Name")

def fullInstallerTask64 = tasks.register('generateFullInstaller64', Task) {
    def zipFile = generateFullZip64BaseTask.get().archivePath
    inputs.file zipFile
    outputs.file fullInstaller64

    dependsOn generateFullZip64BaseTask

    doLast {
        copy {
            from zipFile
            into "$buildDir/outputs"
            rename { fullInstaller64Name }
        }

        installerFile.withInputStream { InputStream inputStream ->
            RandomAccessFile foStream;
            try {
                foStream = new RandomAccessFile(fullInstaller64, "rw");
                foStream.write(inputStream.getBytes())
            } finally {
                if (foStream != null) {
                    foStream.close();
                }
            }
        }
    }
}

tasks.register('generateInstallers', Task) {
    dependsOn fullInstallerTask32
    dependsOn fullInstallerTask64
    dependsOn upgradeInstallerTask
}
